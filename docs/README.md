## Overview

The three main modules are `remill`, `elfconv/lifter`, and `elfconv/runtime`.  
<img width="1051" alt="Screenshot 2025-02-12 13 47 01" src="https://github.com/user-attachments/assets/014c930f-f163-4d15-b995-b1c172b8569b" />

The primary functions of elfconv are the following two:

- **Process to convert ELF to LLVM IR**
  - Two programs are involved: [`lifter/`](https://github.com/yomaytk/elfconv/tree/main/lifter) and [`remill`](https://github.com/yomaytk/elfconv/tree/main/backend/remill).
  - `lifter`: Parses the ELF binary, retrieves the functions, and feeds them into `remill`.
  - `remill`: A library that converts machine code into a sequence of LLVM IR instructions that perform equivalent operations. It converts each sequence of machine code instructions received from `lifter` into a function comprising equivalent LLVM IR instructions. Additionally, `lifter` uses the converted functions generated by `remill` to generate the LLVM bitcode.
  - The source code is as follows.
    - [`lifter/Lift.cpp`](https://github.com/yomaytk/elfconv/blob/main/lifter/Lift.cpp): Corresponds to the main function of the conversion process. It handles everything from ***binary loading***(`manager.SetELFData`), ***converting each instruction in each function***(`for (const auto &[addr, dasm_func] : manager.disasm_funcs){...}`), to ***generating the LLVM bitcode***(`remill::StoreModuleToFile`).
    - [`lifter/MainLifter.cpp`](https://github.com/yomaytk/elfconv/blob/main/lifter/MainLifter.cpp): The main class that actually performs the conversion. It inherits from the base instruction conversion class `remill::TraceLifter`. While it mainly adds functions such as copying the ELF data section into the generated LLVM bitcode, the definition from `TraceLifter` is almost entirely used for machine code conversion.
    - [`lifter/TraceManager.cpp`](https://github.com/yomaytk/elfconv/blob/main/lifter/TraceManager.cpp): Defines several helper functions.

- **Program that links the generated LLVM IR to create an executable (although for ELF/x86-64 this might be less of a concern)**
  - Performs various initialization processes such as register initialization, setting up the stack and heap, and jumping to the entry point. Source code: [`runtime/Entry.cpp`](https://github.com/yomaytk/elfconv/blob/main/runtime/Entry.cpp)
  - Linux system call implementation  
    - Since the original ELF is a program that can execute arbitrary Linux system calls, it is necessary to allow them to work in the environment of the target binary. However, as many standard library functions corresponding to system calls are defined, in many cases it is sufficient to simply align the arguments and call them. The implementation is still a work in progress. Source code: [`runtime/syscalls`](https://github.com/yomaytk/elfconv/tree/main/runtime/syscalls).
  - Runtime memory management  
    - In elfconv, multiple data sections (e.g., the .data section) contained in the ELF are copied into the generated LLVM bitcode. Since the original ELF machine code uses calculated virtual addresses to access these data sections, it is necessary to convert those addresses into the addresses of the copied areas in the LLVM bitcode. Moreover, by defining virtual addresses for the stack and heap, all memory accesses can be unified through address translation. Source code: [`runtime/Memory.cpp`](https://github.com/yomaytk/elfconv/tree/main/runtime/Memory.cpp), [`runtime/Runtime.cpp`](https://github.com/yomaytk/elfconv/tree/main/runtime/Runtime.cpp), [`runtime/VmIntrinsics.cpp`](https://github.com/yomaytk/elfconv/tree/main/runtime/VmIntrinsics.cpp).

## remill

### What Kind of LLVM IR Does It Convert Machine Code Into?
remill takes an array of machine code bytes and converts each machine instruction into LLVM IR that exhibits equivalent behavior. Since machine code is executed not only on memory but also using CPU registers, remill represents CPU registers as a struct (see the [AArch64 definition](https://github.com/yomaytk/elfconv/blob/88545c6ee76444c34da8005a9d8101064670261d/backend/remill/include/remill/Arch/AArch64/Runtime/State.h#L304-L329)). Based on that, here is an illustration of the conversion process. In this example, the following three AArch64 instruction sequences are used:

```asm
add     x29, sp, #0x30
stp     x21, x22, [sp, #80]
adrp    x22, 490000 <tunable_list+0x528>
```

remill converts these into LLVM IR (referred to here as `remill LLVM IR sample`) as follows.

In the LLVM IR below, three basic blocks are generated, with remill converting one machine instruction into one basic block.

The operations performed within a basic block are as follows:
- Retrieve the necessary CPU register values.
- Execute a ***semantics function*** that performs an operation equivalent to the machine instruction, using the retrieved values.
- Jump to the basic block corresponding to the next machine instruction.

For the second instruction, `stp     x21, x22, [sp, #80]` is a store instruction that writes the values of registers x21 and x22 to the address sp + 80. As shown in basic block `20:`, it loads the values `%X21`, `%X22`, and `%SP`. Next, the semantics function for the instruction is executed, as seen in `call void @_ZN12_GLOBAL__N_111StorePair64EP14RuntimeManagermm3MVIIDv1_oE(ptr %runtime_manager, i64 %21, i64 %22, i64 %24)`. As demonstrated below, this performs the operation of writing two 64-bit registers for the STP instruction to an address (functions such as `__remill_write_memory_64` are explained later). Finally, a `br` instruction is used to jump to the next instruction.

```llvm
; remill LLVM IR sample
17:                                               ; preds = %L_indirectbr, %12
  %18 = load i64, ptr %SP, align 8
  %19 = call i64 @_ZN12_GLOBAL__N_13ADDImmEEDaT_T0_(i64 %18, i64 48)
  store i64 %19, ptr %X29, align 8
  br label %20

20:                                               ; preds = %L_indirectbr, %17
  %21 = load i64, ptr %X21, align 8
  %22 = load i64, ptr %X22, align 8
  %23 = load i64, ptr %SP, align 8
  %24 = add i64 %23, 80
  call void @_ZN12_GLOBAL__N_111StorePair64EP14RuntimeManagermm3MVIIDv1_oE(ptr %runtime_manager, i64 %21, i64 %22, i64 %24)
  br label %25

25:                                               ; preds = %L_indirectbr, %20
  %26 = call i64 @_ZN12_GLOBAL__N_14ADRPEm(i64 4787788)
  store i64 %26, ptr %X22, align 8
  br label %27
```

```llvm
// semantics function for STP instruction
define internal void @_ZN12_GLOBAL__N_111StorePair64EP14RuntimeManagermm3MVIIDv1_oE(ptr noundef %runtime_manager, i64 noundef %src1, i64 noundef %src2, i64 %dst.coerce) #0 !remill.function.type !5 {
entry:
  tail call void @__remill_write_memory_64(ptr noundef %runtime_manager, i64 noundef %dst.coerce, i64 noundef %src1) #27
  %add.1.i = add i64 %dst.coerce, 8
  tail call void @__remill_write_memory_64(ptr noundef %runtime_manager, i64 noundef %add.1.i, i64 noundef %src2) #27
  ret void
}
```

### Source Code Explanation

The main directory structure of remill is as follows (omitting non-essential parts):

```plaintext
backend/remill/
          ├─ docs         # The original remill documentation. It may be useful as a reference, though it is quite old.
          ├─ include/remill      # Header files for various remill definition classes
                       ├─ Arch       # Header files for CPU architecture-dependent code       
                       ├─ BC         # Header files for CPU architecture-independent code
          ├─ lib          # Implementation files for various remill definition classes
              ├─ Arch          # CPU architecture-dependent code
              ├─ BC            # CPU architecture-independent code
```
#### lib/Arch/X86

This directory defines the parsing of x86 instructions and the specific helper functions for each instruction.

```plaintext
lib/Arch/X86
          ├─ Runtime       
                ├─ Instructions.cpp       # A single .cpp file that consolidates the .cpp files defining helper functions for instructions. Currently, many of the #includes in this file are commented out.
          ├─ Semantics       # .cpp files that define the helper functions for instructions.
                ├─ AVX.cpp
                ├─ BINARY.cpp
                ├─ ...
          ├─ Arch.cpp      # The code that parses the actual input instruction stream.
```

- For x86 parsing, [Intel XED](https://intelxed.github.io/ref-manual/) is used.

#### lib/BC

Based on the information parsed by lib/Arch, this directory defines the process of actually generating LLVM IR functions.

```plaintext
lib/BC
     ├─ InstructionLifter.cpp        # Defines the process that converts one machine instruction into one basic block. The main function is InstructionLifter::LiftIntoBlock.
     ├─ TraceLifter.cpp              # Defines the process of converting a parsed function into an LLVM IR function. The main function is TraceLifter::Impl::Lift.
```

- `InstructionLifter::LiftIntoBlock`
- `TraceLifter::Impl::Lift`

#### Flow of Machine Code Conversion

Below is the flow describing how a single input machine instruction is converted into LLVM IR:
1.	Within `TraceLifter::Impl::Lift`, `arch->DecodeInstruction` retrieves the machine instruction information. Ultimately, the machine opcode, operands (target CPU registers, memory addresses, etc.) are stored in an instance of `remill::Instruction` named `inst`. Although the inheritance hierarchy is a bit complex and hard to follow, the previously seen `X86Arch::ArchDecodeInstruction` is executed.
2.	Next, `inst.GetLifter()->LiftIntoBlock` generates the equivalent LLVM IR. Two important aspects here are:
    - Retrieving the corresponding semantics function for the instruction (`isel_func = GetInstructionFunction(module, arch_inst.function);` in `Lift.cpp`). If the semantics function for the given machine instruction is not implemented, an error or warning will be issued.
    - Processing the operands (`for (auto &op : arch_inst.operands) {...}` in `InstructionLifter.cpp`). In this, the function LiftOperand generates LLVM IR corresponding to the operands, such as `%21 = load i64, ptr %X21, align 8`.
3.	By step 2, the LLVM IR corresponding to the machine instruction has been generated. Finally, it is necessary to add `br` instruction to jump to the basic block corresponding to the next instruction. This is defined via a switch statement (`switch (inst.category) {...}` in `lib/BC/TraceLifter.cpp`). For example, if the next machine instruction is to be executed, it falls under `case Instruction::kCategoryNormal:`, or if it is a jump, under case `Instruction::kCategoryDirectJump:`, etc.

#### Memory Management

In the original ELF, besides the code section where the machine code is stored, there are several data sections (e.g., .data, .bss) that the machine code frequently accesses. For example, in the case of AArch64, the following instruction sequence accesses the address `0x490000 + 3056` in the data section:

```asm
adrp    x22, 490000 <tunable_list+0x528>
ldr     x0, [x22, #3056]
```

elfconv copies the byte sequences of these data sections into the generated LLVM bitcode. When accessing a data section, the address used is converted to the address of the corresponding copied region. However, even in the LLVM IR generated from the above machine code, the actual computation still uses `0x490000 + 3056`, so it is necessary to convert such addresses into the addresses of the copied regions. With that in mind, remill declares numerous helper functions for memory access for a given virtual address vma, such as `void __remill_write_memory_64(uint64_t vma);`. These helper functions are defined in `runtime/VmIntrinsics.cpp`.

#### Adding Machine Code
- Helper functions for instructions
    - The specific helper functions for each x86 machine instruction are defined in `Arch/X86/Semantics` (currently, a fair number are defined, though modifications are needed for [register optimizations](https://github.com/yomaytk/elfconv/pull/53)). When supporting a new machine instruction, the corresponding semantics function should be added here.
    - remill defines semantics functions used by these instruction-specific functions in [`include/remill/Arch/Runtime/Operators.h`](https://github.com/yomaytk/elfconv/blob/main/backend/remill/include/remill/Arch/Runtime/Operators.h). Although machine code differs greatly between CPUs, many operations are common, so these helper functions are CPU architecture-independent.
- 🚧

## Machine Code Testing

## Debugging
